+++
title = "Code - Adding Behaviors to Flex Components"
date = 2011-03-29T22:38:00Z
updated = 2011-03-29T23:03:53Z
blogimport = true 
[author]
	name = "Sean Wesenberg"
	uri = "https://plus.google.com/111523202047342274226"
+++

It is tempting to write your own flex components that extend the base components (TextInput, Button, etc), because you want to add some functionality or just add your own zip. Having undertaken such a task many times, I can say that things become a mess. Upgrading to a new SDK breaks things, tempts you to update components to the new SDK, breaking more things, etc. Another problem is that once you make your own super awesome button override, you want to use it everywhere, even though a lot of places won't use the new functionality you enabled. This complicates and causes things to break... But...<br /><br /><br /><a name='more'></a><br /><br />Something I prefer doing is the concept of adding 'behavoirs' that extend the functionality of a component, without actually extending it. Your code becomes standard &lt;s:Button /&gt; and you get to add new functionality.&nbsp;It is done simply by creating a class which contains the desired functionality you want to achieve.<br /><br />Let's say you want a TextInput component with prompt support. This means, if the TextInput is empty, it will instead show a 'prompt' giving the user a hint of what they should type in or labeling the field. A common one is a 'Search' field.<br /><br />You could do one of a few things:<br /><br />1. You can override the TextInput component with your own and name it 'TextInput'. The problem with this is confusion, but the benefit is that it's easy to use and if you need more functionality, you just keep tacking stuff on. It gets pretty ugly, pretty fast.<br /><br />2. You could create a new component PromptTextInput. The issue with this is, what happens if you want to add another feature on to TextInput. Say built-in validation or maybe a list that pops up below the field with results. Do you make a new component, do you add the features to the PromptTextInput component you just made?<br /><br />3. Create a 'behavior' that sits outside of the component and interacts with the component. This means, no overriding the component, no deciding between one or two, and add features ala-cart for the use case that you are attempting.<br /><br />A behavior for a component is much like the default Flex validation framework. You write your views using the standard component set, but when you want to add some functionality, you add a behavior. A behavior sits in the &lt;fx:Declerations&gt; tags and references the target component.<br /><br />Enough talking, here is some code...<br /><br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> &lt;?xml version="1.0" encoding="utf-8"?&gt;  <br /> &lt;s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark"  <br />         xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600"  <br />         xmlns:behaviors="behaviors.*" viewSourceURL="srcview/index.html"&gt;  <br />   <br />  &lt;fx:Declarations&gt;  <br />   &lt;behaviors:PromptBehavior target="{i_text}" promptText="search..."/&gt;  <br />  &lt;/fx:Declarations&gt;  <br />   <br />  &lt;s:TextInput id="i_text" horizontalCenter="0" verticalCenter="-15"/&gt;  <br />  &lt;s:Button label="Button" horizontalCenter="0" verticalCenter="15"/&gt;  <br />    <br /> &lt;/s:Application&gt;  <br />   <br /></code></pre><br />And the actual Behavior class...<br /><br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> package behaviors {  <br />   <br />  import flash.events.FocusEvent;  <br />    <br />  import mx.core.UIComponent;  <br />  import mx.events.FlexEvent;  <br />    <br />  import spark.components.TextInput;  <br />  import spark.events.TextOperationEvent;  <br />   <br />  public class PromptBehavior {  <br />   <br />   private var _target:TextInput;  <br />   private var _promptText:String;  <br />   <br />   private var _justFocusedIn:Boolean = false;  <br />   <br />   private var _originalColor:uint;  <br />   private var _originalStyle:String;  <br />     <br />   public function register():void {  <br />    if(!_target || !_promptText) {  <br />     return;// wait until both set...  <br />    }  <br />      <br />    var input:TextInput = _target;  <br />      <br />    // save original settings for later  <br />    _originalColor = input.getStyle("color");  <br />    _originalStyle = input.getStyle("fontStyle");  <br />   <br />    // on creation, check to see if we need to add prompt  <br />    input.addEventListener(FlexEvent.CREATION_COMPLETE, handleCreation);  <br />   <br />    // on focus, remove prompt  <br />    input.addEventListener(FocusEvent.FOCUS_IN, handleFocusIn);  <br />    input.addEventListener(FocusEvent.FOCUS_OUT, handleFocusOut);  <br />   <br />    //add change listener (if we fill in stuff behind the scenes, remove prompt styling)  <br />    input.addEventListener(TextOperationEvent.CHANGE, handleTextChange);  <br />    input.addEventListener(FlexEvent.VALUE_COMMIT, handleValueChange);  <br />   }  <br />   <br />   public function unregister():void {  <br />    var input:TextInput = _target;  <br />    input.removeEventListener(FlexEvent.CREATION_COMPLETE, handleCreation);  <br />    input.removeEventListener(FocusEvent.FOCUS_IN, handleFocusIn);  <br />    input.removeEventListener(FocusEvent.FOCUS_OUT, handleFocusOut);  <br />    input.removeEventListener(TextOperationEvent.CHANGE, handleTextChange);  <br />    input.removeEventListener(FlexEvent.VALUE_COMMIT, handleValueChange);  <br />   }  <br />     <br />   public function set target(value:TextInput):void {  <br />    _target = value;  <br />    register();  <br />   }  <br />     <br />   public function set promptText(value:String):void {  <br />    _promptText = value;  <br />    register();  <br />   }  <br />   <br />   private function handleCreation(event:FlexEvent):void {  <br />    var input:TextInput = event.currentTarget as TextInput;  <br />   <br />    if (isEmpty(input.text)) {  <br />     input.text = _promptText;  <br />     addPromptStyle(input);  <br />    }  <br />   }  <br />   <br />   private function handleFocusIn(event:FocusEvent):void {  <br />    var input:TextInput = event.currentTarget as TextInput;  <br />    removePromptStyle(input); //remove prompt if it is active and we just focused in  <br />   <br />    if (input.text == _promptText) {  <br />     _justFocusedIn = true;  <br />     input.text = "";  <br />    }  <br />   }  <br />   <br />   private function handleFocusOut(event:FocusEvent):void {  <br />    var input:TextInput = event.currentTarget as TextInput;  <br />   <br />    if (isEmpty(input.text)) {  <br />     input.text = _promptText;  <br />     addPromptStyle(input);  <br />    }  <br />   }  <br />   <br />   private function handleTextChange(event:TextOperationEvent):void {  <br />    var input:TextInput = event.currentTarget as TextInput;  <br />    removePromptStyle(input);  <br />   }  <br />   <br />   private function handleValueChange(event:FlexEvent):void {  <br />    var input:TextInput = event.currentTarget as TextInput;  <br />   <br />    if (_justFocusedIn) {  <br />     _justFocusedIn = false;  <br />     return;  <br />    }  <br />   <br />    if (isEmpty(input.text)) {  <br />     input.text = _promptText;  <br />     addPromptStyle(input);  <br />    } else {  <br />     removePromptStyle(input);  <br />    }  <br />   }  <br />   <br />   private function addPromptStyle(input:TextInput):void {  <br />    input.setStyle("color", 0x999999);  <br />    input.setStyle("fontStyle", "italic");  <br />   }  <br />   <br />   private function removePromptStyle(input:TextInput):void {  <br />    input.setStyle("color", _originalColor);  <br />    input.setStyle("fontStyle", _originalStyle);  <br />   }  <br />   <br />   private function isEmpty(value:String):Boolean {  <br />    if (value == null || value == "") {  <br />     return true;  <br />    }  <br />    return false;  <br />   }  <br />   <br />  }  <br /> }  </code></pre><br />What I would like to see next from Adobe is inline support of this stuff, so instead of declaring behaviors in our &lt;fx:Declaration /&gt;. We can declare them as children of components.<br /><br />&lt;s:TextInput&gt;<br />&nbsp;&nbsp;&lt;be:PromptBehavior /&gt;<br />&lt;/s:TextInput&gt;<br /><br />What I wonder is if we could rewrite many of these components and simply rely on behaviors to add functionality that isn't absolutely crucial. Perhaps this would speed up the creation and efficiency of the view stack?
