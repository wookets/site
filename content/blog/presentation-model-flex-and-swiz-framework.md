+++
title = "Presentation Model Flex and Swiz Framework"
date = 2011-06-22T17:53:00Z
updated = 2011-06-22T17:53:50Z
tags = ["Code"]
blogimport = true 
[author]
	name = "Sean Wesenberg"
	uri = "https://plus.google.com/111523202047342274226"
+++

The importance of using a presentation model for keeping your flex pages clean of code and your backend methods reactionary.<br /><br />Here is an example of a typical flex file.<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br />&lt;af:AdminResourceBase xmlns:mx="http://www.adobe.com/2006/mxml" <br />  xmlns:appcore="http://www.wookets.com/flex"<br />  creationComplete="setup()"<br />  clipContent="false" label="Add"&gt;<br /><br />&lt;!-- control --&gt;<br />&lt;mx:Script&gt;<br />  &lt;![CDATA[<br />    import com.wookets.query.dto.Find;<br />    import appcore.query.Tide;<br />    import com.wookets.core.model.User;<br />    import com.wookets.track.model.AppAward;<br />    import mx.collections.ArrayCollection;<br /><br />    private function setup():void {<br />      loadUsers();<br />    }<br />    <br />    public override function beforeSave():void {<br />      b_add.enabled = false;<br />      b_add.label = "adding...";<br />    }<br />    public override function afterSave():void {<br />      super.afterSave();<br />      b_add.enabled = true;<br />      b_add.label = "add";<br />    }<br />    <br />    private function loadUsers():void {<br />      Tide.findAll(new Find(User).orderBy("name"), <br />        function(result:Array):void {<br />          f_user.dataProvider = result;<br />        });<br />    }<br />    <br />  ]]&gt;<br />&lt;/mx:Script&gt;<br /><br />&lt;!-- view --&gt;<br />&lt;mx:Form verticalGap="20" width="100%" borderStyle="solid"&gt;<br />  &lt;mx:FormItem&gt;<br />    &lt;mx:Label text="Award Title"/&gt;<br />    &lt;appcore:TextInput id="f_name" bindTo="sr.name"<br />      width="300" minLength="3" maxLength="120"/&gt;<br />  &lt;/mx:FormItem&gt;<br />  &lt;mx:FormItem&gt;<br />    &lt;mx:Label text="Award Key"/&gt;<br />    &lt;appcore:TextInput id="f_keyname" bindTo="sr.awardKey"<br />      width="300" minLength="3" maxLength="120"/&gt;<br />  &lt;/mx:FormItem&gt;<br />  &lt;mx:FormItem&gt;<br />    &lt;mx:Label text="User Granted the Award"/&gt;<br />    &lt;appcore:ComboBox id="f_user" bindTo="sr.user" labelField="name"/&gt;<br />  &lt;/mx:FormItem&gt;<br />  &lt;mx:FormItem direction="horizontal"&gt;<br />    &lt;appcore:CheckBox id="f_active" bindTo="sr.active"/&gt;<br />    &lt;mx:Text text="Show this resource on the website immediately after it is created?"/&gt;<br />  &lt;/mx:FormItem&gt;<br />  &lt;mx:FormItem&gt;<br />    &lt;appcore:Button id="b_add" label="add" click="save()" enableWhenValid="{[f_name,f_keyname]}"/&gt;<br />  &lt;/mx:FormItem&gt;<br />&lt;/mx:Form&gt;<br /><br />&lt;/af:AdminResourceBase&gt;<br /></pre><br />Which I will tell you is not too bad... However, assigning 'id' to some components and having the methods rely on the view can really create havoc. What happens when you change the view or redesign something? What if a rogue prosigner decides to rewrite your admin pages?<br /><br />A better / cleaner&nbsp;separation&nbsp;of concerns can be found using the presentation model pattern (see references below).<br /><br />Here is a view I just wrote using the presentation model design pattern. First the UI;<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br />&lt;s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" xmlns:s="library://ns.adobe.com/flex/spark"<br />         xmlns:mx="library://ns.adobe.com/flex/mx" currentState="@{pm.currentState}"&gt;<br />  <br />  &lt;fx:Script&gt;<br />    &lt;![CDATA[<br />      import view.pm.GoalsViewPM;<br />      <br />      [Bindable] [Inject] public var pm:GoalsViewPM;<br />    ]]&gt;<br />  &lt;/fx:Script&gt;<br />  <br />  &lt;s:states&gt;<br />    &lt;s:State name="list"/&gt;<br />    &lt;s:State name="edit"/&gt;<br />    &lt;s:State name="new"/&gt;<br />  &lt;/s:states&gt;<br />  <br />  &lt;s:VGroup height="100%" width="100%"&gt;<br />    &lt;s:HGroup width="100%"&gt;<br />      &lt;s:TextInput width="100%" prompt="Search..." change="{pm.search(event.currentTarget.text)}"/&gt;<br />    &lt;/s:HGroup&gt;<br />    &lt;mx:DataGrid dataProvider="{pm.session.goalsList}" height="100%" width="100%"<br />                 change="{pm.changeSelected(event.currentTarget.selectedItem)}"&gt;<br />      &lt;mx:columns&gt;<br />        &lt;mx:DataGridColumn dataField="name" headerText=""/&gt;<br />      &lt;/mx:columns&gt;<br />    &lt;/mx:DataGrid&gt;<br />    &lt;s:VGroup width="100%" includeIn="edit,new"&gt;<br />      &lt;s:Form&gt;<br />        &lt;s:FormHeading label.edit="Editing {pm.selectedGoal.name}" label.new="Creating..."/&gt;<br />        &lt;s:FormItem&gt;<br />          &lt;s:TextInput /&gt;<br />        &lt;/s:FormItem&gt;<br />      &lt;/s:Form&gt;<br />    &lt;/s:VGroup&gt;<br />  &lt;/s:VGroup&gt;<br />  <br />&lt;/s:Group&gt;<br /><br /></pre><br />And the backend AS3 code;<br /><br /><pre class="brush:as3">package view.pm {<br /><br />  import actifi.query.QueryService;<br />  <br />  import com.temp.model.SmartGoal;<br />  import com.wookets.query.dto.Find;<br />  <br />  import core.context.SessionContext;<br />  <br />  import mx.collections.ArrayCollection;<br /><br />  public class GoalsViewPM {<br /><br />    [Bindable] public var currentState:String;<br />    [Bindable] public var selectedGoal:SmartGoal;<br />    <br />    [Inject]<br />    [Bindable] public var session:SessionContext;<br />    [Inject]<br />    public var query:QueryService;<br /><br />    <br />    [PostConstruct]<br />    public function setup():void {<br />      if (session.goalsList == null) {<br />        var find:Find = new Find().from(SmartGoal);<br />        query.findAll(find).onResult(function(result:Array):void {<br />          session.goalsList = new ArrayCollection(result);<br />          session.goalsList.filterFunction = function(item:Object):Object {<br />            return item.name.match(new RegExp(searchString, 'i'));<br />          }<br />        });<br />      }<br />    }<br />    <br />    private var searchString:String = "";<br />    public function search(input:String):void {<br />      searchString = input;<br />      session.goalsList.refresh();<br />    }<br />    <br />    public function changeSelected(value:SmartGoal):void {<br />      selectedGoal = value;<br />      if(selectedGoal != null) {<br />        currentState = "edit";<br />      } else {<br />        currentState = "list";<br />      }<br />    }<br />    <br />  }<br />}<br /></pre><br />More code right? Yes... And the code is in two different files... Pretty annoying, but not when you think about it... The view is highly decoupled from the control. Yes, the view utilizes and makes references to methods and models of the control, but we can't really get around that... The control actually has no reference what so ever to the view. Your local rogue prosigner can change the View (mxml) to his / her hearts content and it won't mess up your control. The view always reacts to the control. The control never changes when the view changes (unless you're making the view richer, in which case you are always adding things and never changing existing functionality).<br /><br />This is also helpful when writing tests... Tests can run against your controls without a care for a view being present.<br /><br />The fact that there are no more ids being assigned to components or trying to decide which way to code... A binding, an id, use the event? Just use the PM and you're done.<br /><br />(sorry for the lack of an example project)<br /><br />References:<br /><br /><a href="http://swizframework.org/">http://swizframework.org/</a><br /><br /><a href="http://swizframework.jira.com/wiki/display/SWIZ/Presentation+Model">http://swizframework.jira.com/wiki/display/SWIZ/Presentation+Model</a>
