+++
title = "Pushing domain language down to byte code"
date = 2011-09-17T15:33:00Z
updated = 2011-09-17T15:33:26Z
tags = ["Thoughts", "Architecture", "Code"]
draft = true
blogimport = true 
[author]
	name = "Sean Wesenberg"
	uri = "https://plus.google.com/111523202047342274226"
+++

There is an ever increasing push with software frameworks and languages to do more with less. A fews line of Groovy can replace hundreds of Java. A few lines of C# replaces hundreds of C++. And each framework is augmented by numerous libraries and plug-ins that help you achieve a myriad of tasks.&nbsp;What we need is less implementation from the language writers and more DSL support that adhere to a spec sheet.<br /><br />Example; The Spring Framework (Java based IoC) designed that pattern that they will handle the spec and the wiring, but it's up to other people to actually write the functionality.&nbsp;Inversion&nbsp;of control. Instead of bundling everything under the sun with your runtime, make people choose and add dependancies on what they need.&nbsp;Now, software already does this. If it didn't, we'd have massive system floating around. But, I think we should take one step further and mix in DSLs.<br /><br />mail<br />&nbsp; to: "support@facebook.com"<br />&nbsp; subject: "I have a bug in my eye"<br />&nbsp; body: "What should I do?"<br /><br />The above instruction set is pretty straight forward. Let's mail support@facebook.com that we have a bug in our eye. A similar instruction set in Java using Spring.<br /><br />@Autowired public MailService mail;<br /><br />public void mail() {<br />&nbsp; mail.send("support@facebook.com", "I have a...);<br />}<br /><br />You get the idea...<br /><br />So... what I'm trying to get at... Can we make a framework that allows us to take a plug-in (in our case 'mail') and write the first example...<br /><br />Well, we have that, don't we? I mean, Groovy has support for DSLs, right? My issue is, I want to see DSLs taken to the next step. A framework that doesn't just work with one language, but many.<br /><br /><br /><br /><br /><br /><br />The problem with this, is that we are continually creating new syntaxii do describe what we want the damn machine to do. This is fine if you like learning new languages, but for the rest of us, adding a new language hurts more than it helps. The world after all needs standards and commonality at some point to interface.<br /><br />I think it more wise to consider creating languages for specific purposes, instead of generality. There is something to be said for...<br /><br />class UserController {<br />&nbsp; def index = {<br />&nbsp; &nbsp; println "What up?"<br />&nbsp; }<br />}<br /><br />A concise bit of code that means absolutely nothing (for the most part) outside of the context of a java web server running groovy and grails. class is carried forward, but isn't necessary, def is carried over, println is pretty&nbsp;ambiguous&nbsp;from a web prospective... print a line where and to what and why? php echo is even worse.<br /><br />It isn't that we should abandon these new languages, but we should define categorically upfront what they are for. Yes, programing languages and frameworks can do just about everything, but do we really want them to? No, we want our Rails and Grails to do web applications (REST, MVC). And we want our Node.js to handle concurrent small tasks, and we want our Java to handle long running processing, and we want our Cs to run our games closer to the iron.<br /><br />Taking one language and bastardizing it to fit a problem that it never intended to and truthfully has no business solving is not what we should be doing. Yes, flexibility and options are all well and good, but they lead to confusion and productivity losses.<br /><br />A better approach is to create DSLs. Domain specific languages. Now, you're probably up and arms... "DSLs are for business people." But, the reality is, DSLs are just simplifications on a solving a niche problem. The same thing Rails is trying to do, Node.js is trying to do. A language doesn't run faster, a framework that requires less to support runs faster. And the point of the DSL is to support what is needed, not what is bundled.<br /><br />The above example was a groovy / grails snippet. The same code in java w/ spring.<br /><br />@Controller<br />public class UserController {<br />&nbsp; @RequestUrl("/index")<br />&nbsp; public void handleIndex() {<br />&nbsp; &nbsp; System.out.println("What up?");<br />&nbsp; }<br />}<br /><br />If we could take it even further... Assuming our own DSL...<br /><br />"/index"<br />&nbsp; show "What up?"<br /><br />
