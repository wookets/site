+++
title = "SAML 2.0 using Groovy and Spring (part 1)"
date = 2011-11-22T13:07:00Z
updated = 2011-11-22T21:37:07Z
tags = ["Code"]
blogimport = true 
[author]
	name = "Sean Wesenberg"
	uri = "https://plus.google.com/111523202047342274226"
+++

<b>Overview</b><br /><br />Recently I have had to do a small SAML 2.0 integration project for one of our clients to enable single sign on. Here are some thoughts on the issue.<br /><br /><b>Saml 2.0 is pretty easy</b><br /><br />Much can be said about SOAP and insane and inane web service API's, but SAML 2.0 is pretty straight forward. The basic flow can be summed;<br /><br />System A -&nbsp;Identity&nbsp;holder<br />This system is the authority of authentication for our users.<br /><br />System B - Third party<br />This system is the requester of access. This system asks, "Is this user authenticated?"<br /><br />How do the systems talk?<br /><br /><ol><li>User clicks on a link to System B from System A. (i.e. we want to launch System B, we are already logged into System A)</li><li>System B creates a request and sends it to System A. (this is done through the User via redirection of their browser to System A with a token from System B)</li><li>System A sends a POST to System B which contains a 'success' or 'failure' message. System B then logs the user in and redirects to the&nbsp;appropriate&nbsp;and originally requested resource.&nbsp;</li></ol><br />That's essentially it...<br /><br /><b>The nitty-gritty</b><br /><b><br /></b><br />You can go a few ways... Probably your best bet would be to go the <a href="https://wiki.shibboleth.net/confluence/display/OpenSAML/Home">OpenSAML</a> route. However, I don't like to add jars to my java projects and given that we're using Groovy and Spring, XML parsing / creation + HTTP handlers are pretty easy.<br /><br />I should mention that I have done merely the System B approach to SAML 2.0, so we will not be creating an assertion. Though, I've used one to test my 'verifyAssertion' handler.<br /><b><br /></b><br /><b>A Spring based SAML Controller (part 1) </b><br /><br /><pre class="brush:java">package demo.saml2<br /><br />import java.util.zip.Deflater;<br />import java.util.zip.DeflaterOutputStream;<br /><br />import javax.servlet.http.HttpServletResponse;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Controller;<br />import org.springframework.web.bind.annotation.RequestMapping;<br />import org.springframework.web.bind.annotation.RequestParam;<br /><br />@Controller<br />class SAMLController {<br /><br />  @Autowired SAMLService samlService<br />  <br />  static def RedirectUrl = "https://www.wookets.com/sso/saml2/handleresponse"<br />  <br />  @RequestMapping(value = "/sso/saml2/createrequest")<br />  def createSamlRequest(HttpServletResponse response, @RequestParam String redirectUrl) {<br />    log.debug "Creating a new AuthnRequest"<br />    <br />    // write a request out<br />    String authn = '&lt;?xml version="1.0" encoding="UTF-8"?&amp;rt;' // adding this even though it might not be needed<br />    authn += samlService.createAuthnRequest()<br />    <br />    // url encode<br />    Deflater deflater = new Deflater(Deflater.DEFLATED, true);<br />    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();<br />    DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater);<br />    deflaterOutputStream.write(authn.getBytes());<br />    deflaterOutputStream.close();<br />    String samlResponse = byteArrayOutputStream.toByteArray().encodeBase64().toString()<br />    def encodedAuthn = URLEncoder.encode(samlResponse, "UTF-8")<br />    <br />    // send a redirect<br />    response.sendRedirect(RedirectUrl + "?SAMLRequest=" + encodedAuthn)<br />    <br />    log.debug "${RedirectUrl}?SAMLRequest=${encodedAuthn}"<br />  }<br />}<br /><br /></pre>Notes:<br />- We are using a basic Spring @Controller to accept an HTTPRequest and set the response<br /><br />- redirectUrl is not part of SAML 2.0, but is a helper method for your partner. Instead of you hardcoding their URL, they simply pass the URL to you.<br /><br />- The response needs to be; 1) zipped, 2) base64 encoded, 3) url encoded. And in that order.<br /><br />- Notice that we are using a GET redirect variable. This is because redirect wipes the body out when we send it to the client (the client actually wipes it, but we can only pass variables through the URL)<br /><br /><br /><b>A Spring based SAML Service (part 1)</b><br /><br /><br /><pre class="brush:java">package demo.saml2<br /><br />import groovy.xml.MarkupBuilder;<br /><br />import org.springframework.stereotype.Service;<br /><br />@Service<br />class SAMLService {<br /><br />  def createAuthnRequest = {<br />    log.debug "Creating an AuthnRequest"<br />    <br />    // define variables to create saml AuthnRequst<br />    def requestId = "ThisShouldBeRandomlySecurelyGenerated"<br />    def timestamp = Calendar.instance.getTime().format("yyyy-MM-dd'T'HH:mm:ss'Z'") //String.format('%tFT%tTZ', cal)<br />    def providerName = "https://www.partnerurl.com" // this is just whatever your partner has it set to<br />    def verifyAssertionUrl = "https://www.wookets/sso/saml/verifyassertion" // this is the callback url<br />    <br />    // save requestId to db for later use...<br />    <br />    // create saml token<br />    def writer = new StringWriter()<br />    def xml = new MarkupBuilder(writer)<br />    xml.doubleQuotes = true<br />    xml."samlp:AuthnRequest"("xmlns:samlp": "urn:oasis:names:tc:SAML:2.0:protocol",<br />        AssertionConsumerServiceIndex: "0", AssertionConsumerServiceURL: verifyAssertionUrl,<br />        ForceAuthn: "true", ID: requestId, IsPassive: "false", IssueInstant: timestamp,<br />        ProtocolBinding: "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect",<br />        ProviderName: providerName, VERSION: "2.0") {<br />      "saml:Issuer"("xmlns:saml":"urn:oasis:names:tc:SAML:2.0:assertion", providerName)<br />      "samlp:NameIDPolicy"(AllowCreate: "true")<br />    }<br />    log.debug "returning: ${writer.toString()}"<br />    return writer.toString()<br />  }<br />  <br />}<br /></pre><br />Notes:<br />- We could have just put this all in the Controller, but I created a Service, because of separation of concerns... You may not have concerns which need separating...<br /><br />- This groovy closure generates a unique secured id and uses that and a timestamp to create the AuthnRequest. Note, I'm not using OpenSAML or any jars here. Just groovy putting together the XML according to the spec and what the partner is expecting. Your mileage may vary.<br /><br /><br /><b>Resources</b><br /><br /><a href="https://wiki.shibboleth.net/confluence/display/OpenSAML/Home">https://wiki.shibboleth.net/confluence/display/OpenSAML/Home</a><br /><br /><a href="http://en.wikipedia.org/wiki/SAML_2.0">http://en.wikipedia.org/wiki/SAML_2.0</a>
