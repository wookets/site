+++
title = "A Spring Controller Invoker Service w/ Groovy Named Params"
date = 2011-11-06T20:53:00Z
updated = 2011-11-07T19:52:36Z
tags = ["Code"]
blogimport = true 
[author]
	name = "Sean Wesenberg"
	uri = "https://plus.google.com/111523202047342274226"
+++

I'm attempting to use the invoker pattern with a spring controller. For instance...<br /><i>/app/invoke/hamburger/makeme</i><br />Navigating to this URL with either a GET or a POST should do the following...<br /><ol><li>1. Look up and get a service called 'HamburgerService' from the spring context.</li><li>2. Invoke a method on our service bean called 'makeme'</li><li>3. If any params are passed in, pass them in as arguments to the makeme method.</li></ol>Example Groovy code:<br /><b>HamburgerService.groovy</b><br /><pre class="brush:java">class HamburgerService {<br />  def makeme(Boolean withCheese, String sauce) {<br />    // make delicious samy<br />  }<br />}<br /></pre><b>ServiceInvoker.groovy</b><br /><pre class="brush:java">@Controller<br />class ServiceInvoker {<br />  @RequestMapping(value = "/invoke/{service}/{method}")<br />  def handleServiceInvoker(@PathVariable String service, @PathVariable String method, WebRequest request) {<br />    def bean = Lookup.get(service)<br />    bean."$method"(request.getParameterMap())<br />  }<br />}<br /></pre><br />The problem is... And by the way the above code is not complete or functional by any means... How do we take a potentially unordered list of parameters passed in to our Controller and reflect on the service class and pass in an ordered list of values...<br /><br />The solution? I don't really know... Seems the best solution is to avoid the ordered list of the Service method. This makes things a bit hairy from a java prospective, but actually works out quite well from a groovy prospective.<br /><br />Now, instead of calling (a basic call here...)<br /><pre class="brush:java"><br />hamburgerService.makeme(true, "spicy mayo")<br /></pre>We can (have to)...<br /><pre class="brush:java"><br />hamburgerService.makeme(withCheese: true, source: "spicy mayo")<br /></pre>And our method signature changes to...<br /><pre class="brush:java"><br />def makeme(Map args) { }<br /></pre>or<br /><pre class="brush:java"><br />def makeme = { Boolean withCheese, String sauce -&gt;<br />}<br /></pre><br />or<br /><pre class="brush:java"><br />def makeme = {<br />&nbsp; it.withCheese<br />&nbsp; it.sauce<br />}<br /></pre><br />Perhaps this is the best way and maybe this is how programming should be done. If you think about it, arguments of a method signature are&nbsp;arbitrary&nbsp;and should be expected unordered. Why do we care how things are passed in, just that they are passed in.<br /><br />But, this does break our 'Strong' method signature. Perhaps our compilers should be reflecting on the doc in the comments and based on that determine what the method wants (hey it would force us to have good docs)...<br /><br />Hmm...<br /><br /><br /><br />
